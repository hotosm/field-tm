# Copyright (c) Humanitarian OpenStreetMap Team
#
# This file is part of Field-TM.
#
#     Field-TM is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     Field-TM is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with Field-TM.  If not, see <https:#www.gnu.org/licenses/>.
#
"""DTOs and schemas for project endpoints."""

from typing import Annotated, Optional, Self, Union

from geojson_pydantic import (
    Feature,
    FeatureCollection,
    MultiPolygon,
    Polygon,
)
from litestar.datastructures import UploadFile
from litestar.dto import DataclassDTO, DTOConfig
from pydantic import BaseModel, ConfigDict, Field, ValidationInfo
from pydantic.functional_validators import field_validator, model_validator

from app.central.central_schemas import ODKCentral
from app.config import encrypt_value
from app.db.enums import (
    FieldMappingApp,
    ProjectPriority,
    ProjectStatus,
    TaskSplitType,
)
from app.db.models import DbProject, slugify
from app.db.postgis_utils import geojson_to_featcol, merge_polygons


class SplitFormData(BaseModel):
    """Form data for split square task split."""

    model_config = ConfigDict(arbitrary_types_allowed=True)
    project_geojson: UploadFile
    extract_geojson: UploadFile | None = None


# ============================================================================
# DTOs for endpoint responses
# ============================================================================


# DTO for project responses (excludes sensitive/internal fields)
class ProjectOut(DataclassDTO[DbProject]):
    """DTO that excludes sensitive fields from project responses."""

    config = DTOConfig(
        exclude={
            "xlsform_content",  # Don't serialize binary XLSForm content
            "external_project_password_encrypted",  # Don't expose encrypted passwords
        },
    )


# DTO for project summaries (subset of DbProject fields for listings)
# NOTE: For paginated responses, use PaginatedProjectSummariesOut instead
class ProjectSummary(DataclassDTO[DbProject]):
    """DTO for project summaries with subset of fields."""

    config = DTOConfig(
        include={
            "id",
            "project_name",
            "hashtags",
            "location_str",
            "description",
            "external_project_id",
            "external_project_instance_url",
            "status",
            "visibility",
            "field_mapping_app",
        },
    )


# ============================================================================
# Input validation models (used in routes but not DTOs)
# NOTE: These remain as Pydantic models because they have complex validation
# logic (hashtag parsing, GeoJSON merging, token encryption, etc.)
# ============================================================================


class StubProjectIn(BaseModel):
    """Input model for creating a project stub (with validators)."""

    # Autogenerated fields
    location_str: Annotated[
        Optional[str],
        Field(exclude=True),
    ] = None
    slug: Annotated[
        Optional[str],
        Field(exclude=True),
    ] = None
    created_by_sub: Annotated[
        Optional[str],
        Field(exclude=True),
    ] = None

    project_name: str
    field_mapping_app: FieldMappingApp
    description: Optional[str] = None
    merge: bool = True
    outline: MultiPolygon | Polygon = None
    status: Optional[ProjectStatus] = None
    hashtags: Optional[list[str]] = []

    @field_validator("hashtags", mode="before")
    @classmethod
    def validate_hashtags(
        cls,
        hashtags: Optional[str | list[str]],
    ) -> Optional[list[str]]:
        """Validate hashtags.

        - Receives a string and parsed as a list of tags.
        - Commas or semicolons are replaced with spaces before splitting.
        - Add '#' to hashtag if missing.
        """
        if hashtags is None:
            return None

        if isinstance(hashtags, str):
            hashtags = hashtags.replace(",", " ").replace(";", " ")
            hashtags_list = hashtags.split()
        else:
            hashtags_list = hashtags

        # Add '#' to hashtag strings if missing
        return [
            f"#{hashtag}" if hashtag and not hashtag.startswith("#") else hashtag
            for hashtag in hashtags_list
        ]

    @field_validator("outline", mode="before")
    @classmethod
    def parse_input_geojson(
        cls,
        value: FeatureCollection | Feature | MultiPolygon | Polygon,
        info: ValidationInfo,
    ) -> Optional[Union[Polygon, MultiPolygon]]:
        """Parse any format geojson into a single Polygon or MultiPolygon.

        NOTE we run this in mode='before' to allow parsing as Feature first.
        """
        if value is None:
            return None

        # Check for invalid geometry types (Point, MultiPoint) and raise ValidationError
        geom_type = None
        if isinstance(value, dict):
            geom_type = value.get("type")
            # Check if it's a Feature or FeatureCollection
            if geom_type == "Feature":
                geom_type = value.get("geometry", {}).get("type")
            elif geom_type == "FeatureCollection":
                features = value.get("features", [])
                if features:
                    geom_type = features[0].get("geometry", {}).get("type")
        elif hasattr(value, "type"):
            # Handle geojson_pydantic geometry objects
            geom_type = getattr(value, "type", None)

        if geom_type in ["Point", "MultiPoint"]:
            from pydantic import ValidationError

            # Raise ValidationError that will result in 422 status code
            raise ValidationError.from_exception_data(
                "ValueError",
                [
                    {
                        "type": "value_error",
                        "loc": ("outline",),
                        "msg": f"Invalid geometry type: {geom_type}. Only Polygon, MultiPolygon, LineString, and MultiLineString are supported.",
                        "input": value,
                    }
                ],
            )

        # FIXME also handle geometry collection type here
        # geojson_pydantic.GeometryCollection
        # FIXME update this to remove the Featcol parsing at some point
        featcol = geojson_to_featcol(value)
        merge = info.data.get("merge", True)
        merged_geojson = merge_polygons(
            featcol=featcol, merge=merge, dissolve_polygon=True
        )

        if merge:
            return merged_geojson.get("features")[0].get("geometry")
        else:
            geometries = [
                feature.get("geometry").get("coordinates")
                for feature in merged_geojson.get("features", [])
            ]
            return {"type": "MultiPolygon", "coordinates": geometries}

    @model_validator(mode="after")
    def append_fmtm_hashtag_and_slug(self) -> Self:
        """Append the #Field-TM hashtag and add URL slug."""
        # NOTE the slug is set here as the field_validator above
        # does not seem to work?
        self.slug = slugify(self.project_name)

        if not self.hashtags:
            self.hashtags = ["#Field-TM"]
        elif "#Field-TM" not in self.hashtags:
            self.hashtags.append("#Field-TM")
        return self


class ProjectInBase(StubProjectIn):
    """Base model for project insert / update (validators)."""

    # Override hashtag input to allow a single string input
    hashtags: Annotated[
        Optional[list[str] | str],
        Field(validate_default=True),
    ] = None
    project_name: Optional[str] = None
    field_mapping_app: Optional[FieldMappingApp] = None

    # Token used for ODK appuser; encrypted at rest
    odk_token: Optional[str] = None

    # Add missing vars
    external_project_instance_url: Optional[str] = None
    external_project_id: Optional[int] = None
    external_project_username: Optional[str] = None
    external_project_password_encrypted: Optional[str] = None

    # Exclude (do not allow update)
    id: Annotated[Optional[int], Field(exclude=True)] = None
    outline: Annotated[Optional[dict], Field(exclude=True)] = None

    @field_validator("odk_token", mode="after")
    @classmethod
    def encrypt_token(cls, value: str) -> Optional[str]:
        """Encrypt the ODK Token for insertion into the db."""
        if not value:
            return None
        return encrypt_value(value)


class ProjectIn(ProjectInBase, ODKCentral):
    """Input model for creating a project in ODK Central."""

    # Ensure geojson_pydantic.Polygon
    outline: Optional[Polygon] = None

    # Add task_split_type and priority with enum validation
    # Pydantic will automatically validate these enum types
    task_split_type: Optional[TaskSplitType] = None
    priority: Optional[ProjectPriority] = None

    @property
    def odk_credentials(self) -> Optional[ODKCentral]:
        """Get ODK credentials in decrypted format for API use.

        Returns None if no credentials provided (will use default env credentials).
        """
        # If all ODK fields are None/empty, return None to use default env credentials
        if (
            not self.external_project_instance_url
            and not self.external_project_username
            and not self.external_project_password
        ):
            return None

        # Return ODKCentral instance with plaintext password (already validated)
        return ODKCentral(
            external_project_instance_url=self.external_project_instance_url,
            external_project_username=self.external_project_username,
            external_project_password=self.external_project_password,
        )


class ProjectUpdate(ProjectInBase, ODKCentral):
    """Input model for updating a project (all fields optional)."""

    # The field mapping app should not be updatable
    field_mapping_app: Annotated[Optional[FieldMappingApp], Field(exclude=True)] = None

    # Make required fields from StubProjectIn optional for updates
    project_name: Optional[str] = None
    # Override dict type to parse as Polygon
    outline: Optional[Polygon] = None

    # Add task_split_type and priority with enum validation
    # Pydantic will automatically validate these enum types
    task_split_type: Optional[TaskSplitType] = None
    priority: Optional[ProjectPriority] = None

    # XLSForm binary content for project
    xlsform_content: Optional[bytes] = None
    # GeoJSON data extract stored directly in database
    data_extract_geojson: Optional[dict] = None
